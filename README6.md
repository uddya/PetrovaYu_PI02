# PetrovaYu_PI02
1. Сортировка выбором (Selection Sort)
Определение: Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
Работа алгоритма: 
•	Найти минимальный элемент в неотсортированной части массива и поменять его местами с первым элементом в неотсортированной части.
if arr[j] < arr[min_index]: min_index = j ;
arr[i], arr[min_index] = arr[min_index], arr[i]
•	Теперь эта часть массива считается отсортированной, и алгоритм повторяет предыдущий шаг для оставшейся неотсортированной части.
•	Процесс продолжается до тех пор, пока весь массив не будет отсортирован.
Сложность алгоритма: O(n²)
Объяснение сложности: Выполняется два вложенных цикла for: 
•	Внешний цикл пробегает по каждому элементу массива. Это примерно n итераций.
•	Внутренний цикл для каждого элемента ищет минимальный элемент в оставшейся части массива.

2. Сортировка обменом (пузырьком) (Bubble Sort)
Определение: Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
Работа алгоритма:
•	Проходим по массиву, сравнивая соседние элементы
for (int i = 0; i < n-1; i++) <…>
if (arr[j] > arr[j+1])
•	Если текущий элемент больше следующего, меняем их местами
int temp = arr[j]; 
arr[j] = arr[j+1]; 
arr[j+1] = temp;
•	Повторяем проходы по массиву, пока  весь массив не станет отсортирован по возрастанию (убыванию).
Сложность алгоритма: O(n²)
Объяснение сложности: в худшем случае (когда массив отсортирован в обратном порядке), он выполняет около n-1 проходов по всему массиву, при этом каждый проход содержит примерно n сравнений.  В результате количество операций растёт пропорционально квадрату размера массива.

3. Сортировка вставками (Insertion Sort)
Определение: Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
Работа алгоритма:
•	Принимаем первый элемент за отсортированный.
•	Сравниваем текущий элемент с элементами слева и перемещаем его назад, пока не найдем место, куда его нужно вставить, то есть, пока текущий элемент меньше элемента слева.
while (j >= 0 && array[j] > key) { array[j + 1] = array[j]; j = j – 1;
•	Вставляем текущий элемент в найденную позицию.
array[j + 1] = key;
•	Переходим к следующему элементу и повторяем процесс до конца списка.
Сложность алгоритма: O(n²)
Объяснение сложности: В худшем случае, когда список отсортирован по убыванию, для каждого из n-1 элементов может быть до n сравнений, что даёт квадратичную сложность.

4. Сортировка слиянием (Merge Sort)
Определение: Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
Работа алгоритма:
•	Разделить исходный массив на две половины.
left = arr[:mid] 
right = arr[mid:]
•	Рекурсивно отсортировать каждую половину.
left = merge_sort(left) 
right = merge_sort(right)
•	Соединить две отсортированные половины в один отсортированный массив.
return merge(left, right)
•	def merge_sort(arr):
if len(arr) <= 1: return a
Сложность: O(n log n)
Объяснение сложности: Сложность достигается благодаря двум основным операциям: разбиению массива на две части, что занимает log n, и последующему объединению этих частей, которое требует порядка n операций на каждом уровне рекурсии.

5. Сортировка Шелла (Shellsort)
Определение: Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Работа алгоритма:
•	Выбирается начальный шаг (например, половина длины массива).
•	Выполняется несколько проходов по массиву, сравниваются и меняются местами элементы, которые расположены на этом шаге.
for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) { arr[j] = arr[j - gap]; }
•	Уменьшается шаг (обычно делением на 2 или по другой схеме), и повторяются проходы.
•	Когда шаг достигает 1, выполняется окончательный проход, который сортирует почти отсортированный массив.
Сложность: O(n²)
Объяснение сложности: в наихудшем случае - если выбираются плохие последовательности шагов или массив очень неудачно устроен - алгоритм ведет себя как пузырек или вставка, давая сложность O(n^2) 

6. Быстрая сортировка (Quick Sort)
Определение: Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
Работа алгоритма:
•	Выбирается опорный элемент из массива.
•	Все элементы делятся на две части: меньшие или равные опорному — слева, большее — справа.
for (int j = low; j < high; j++) { if (array[j] <= pivot) { i++; }
•	Рекурсивно применяется тот же процесс к левому и правому подмассиву.
•	В результате после нескольких рекурсивных вызовов объединением всех отсортированных частей получается отсортированный массив.
Сложность: O(n²)
Объяснение сложности: 
В худшем случае (когда опорный элемент выбран наибольшим или наименьшим) разбиение будет очень неравномерным - один из подмассивов будет практически такой же длины, а другой - пустым. В таком случае рекурсия повторяется n раз, а работы на каждом уровне — O(n).

7. Пирамидальная сортировка
Определение: Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
Работа алгоритма:
•	Построить из массива структуру данных «max-куча» — такую, где каждый родитель больше или равен своим детям.
•	После этого вставить "максимальный" элемент в конец массива. Затем уменьшить размер кучи и восстановить свойства кучи (переформировать «кучу»).
for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # меняем корень с последним элементом 
•	Повторить эти шаги для уменьшенного размера кучи, пока не получим полностью отсортированный массив.
Сложность: O(n log n)
Объяснение сложности: Построение кучи занимает O(n) времени. Извлечение максимального (минимального) элемента из кучи и восстановление кучи требует O(log n) на каждое из n таких извлечений. Общий результат - O(n) + O(n log n) = O(n log n)

8. Последовательный (линейный) поиск
Определение: Последовательный (линейный) поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут.
Работа алгоритма:
•	Начинаем с первого элемента массива.
•	Сравниваем текущий элемент с искомым значением.
for(int i = 0; i < size; i++) { if(arr[i] == target)
•	Если они совпадают — поиск завершён, возвращаем индекс найденного элемента (или сам элемент, в зависимости от реализации).
•	Если не совпадают — переходим к следующему элементу.
•	Продолжаем процесс, пока не пройдём весь массив или пока не найдём искомый элемент.
•	Если была проверена вся последовательность и элемент не найден — возвращаем значение, указывающее на отсутствие элемента
Сложность: O(n)
Объяснение сложности: В худшем случае, чтобы найти элемент или удостовериться в его отсутствии, нужно проверить все элементы массива по очереди. Это означает, что количество сравнений прямо пропорционально размеру массива.

9. Бинарный (двоичный, дихотомический) поиск
Определение: Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента.
Работа алгоритма:
•	Изначально у вас есть отсортированный массив.
•	Вы выбираете середину массива.
•	Сравниваете искомый элемент с элементом посередине.
o	Если они совпадают — поиск завершён успешно.
if (array[mid] == target) { return mid; }
o	Если искомый элемент меньше — продолжаем искать в левой половине массива.
if (array[mid] > target) { right = mid – 1; }
o	Если больше — в правой половине.
else { left = mid + 1; }
•	Повторяете эти шаги для выбранной половины до тех пор, пока не найдёте элемент или не останутся элементы для поиска.
Сложность: O(log n)
Объяснение сложности: В худшем случае, чтобы сузить диапазон до одного элемента, потребуется примерно (log n) итераций, потому что после каждого сравнения остается вдвое меньший фрагмент массива

10. Интерполирующий поиск
Определение: Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений.
Работа алгоритма:
•	Начинается с границ поиска: lo = 0, hi = N-1.
•	Вычисляется предполагаемая позиция pos с помощью формулы:
pos = lo + (((hi - lo) * (x - arr[lo])) // (arr[hi] - arr[lo]))
•	Если элемент arr[pos] совпадает с x, поиск завершён успешно.
•	Если arr[pos] меньше x, сдвигаем lo на pos + 1.
•	Если arr[pos] больше x, сдвигаем hi на pos - 1.
•	Повторяем цикл, пока lo <= hi и элемент не найден.
Сложность: O(n)
Объяснение сложности: Когда элементы распределены неравномерно или есть повторяющиеся значения, интерполирующий поиск становится похож на двоичный поиск. В худшем случае сложность - O(n)

11. Поиск по Фибоначчи
Определение: Поиск по Фибоначчи — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
Работа алгоритма:
•	Сначала находится число Фибоначчи, которое больше или равно размеру массива — это определяет разрез.
•	Используется индекс offset = -1.
•	На каждом шаге сравнивается текущий элемент с искомым:
o	Если элемент меньше искомого, сдвигаем offset вперед и уменьшаем диапазон.
o	Если больше — сдвигаем диапазон назад.
•	Если элемент совпадает, возвращается индекс.
•	Если совпадений нет, возвращается, что элемент отсутствует.
Сложность: O(log n)
Объяснение сложности: В каждом шаге алгоритма происходит уменьшение области поиска примерно вдвое или чуть меньше, аналогично двоичному поиску, но деления происходят по длинам, определённым числами Фибоначчи.
