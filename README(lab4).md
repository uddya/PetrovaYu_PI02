Дерево — иерархическая структура данных из узлов, где у каждого узла один родитель (кроме корня) и возможно несколько детей; корень не имеет родителя, 
листья не имеют детей, и такая модель используется, например, для файловых систем и оргструктур.
Граф — нелинейная структура из вершин и рёбер; формально граф задаётся как G=(U,E) где U — множество вершин, E — множество рёбер, причём ребро можно представить 
парой e=[x,y] графы бывают ориентированными/неориентированными и взвешенными/невзвешенными.

Организация Python: список смежности. Для каждой вершины создаётся список (или множество) смежных с ней вершин. Вершины могут быть представлены любыми 
объектами, но номера вершин часто используют как индексы.
def add_edge(graph, start_vertex, end_vertex):
    if start_vertex not in graph:
        graph[start_vertex] = []
    graph[start_vertex].append(end_vertex)

Организация C++: матрица смежности - двумерный массив, где каждая ячейка указывает на наличие или отсутствие ребра между вершинами.
void displayGraph() {
    std::cout << "Матрица смежности:\n";
    for (int i = 0; i < MAX_NODES; ++i) {
        for (int j = 0; j < MAX_NODES; ++j) {
            std::cout << adjacencyMatrix[i][j] << " ";
        }
        std::cout << "\n";
    }
}

Организация Java: матрица смежности - двумерный массив, где каждый элемент представляет вес ребра между двумя узлами. Если между двумя узлами нет ребра, соответствующий элемент в матрице обычно устанавливается в 0 или большое значение, чтобы показать отсутствие соединения. Иногда для организации алгоритма Дейкстры используется очередь с приоритетом. В организации графа с использованием очереди с приоритетом важна структура хранения графа (списки смежности) и правильная реализация приоритетной очереди для выбора минимальных рёбер или расстояний для алгоритмов поиска кратчайших путей.

List<List<Integer>> adjList = new ArrayList<>();
        for (int i = 0; i < vertices; i++) {
            adjList.add(new ArrayList<>());
        }
