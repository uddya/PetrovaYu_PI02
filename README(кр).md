Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
Работа алгоритма:
1. Объявляем функцию bucket_sort, которая принимает список чисел arr для сортировки.
2. Создаём список из 10 пустых списков, которые будут выступать в роли корзин.
3. Проходим по каждому элементу num исходного массива:
Вычисляем индекс корзины index, умножая число на 10 и приводя к целому числу. 
Добавляем число num в соответствующую корзину buckets[index].
4. Для каждой корзины bucket вызываем метод sort(), чтобы отсортировать содержимое внутри корзины.
5. Создаём пустой список sorted_arr. Проходим по каждой отсортированной корзине и расширяем sorted_arr с помощью метода extend(), добавляя элементы из корзины в итоговый массив.
6. Возвращаем итоговый отсортированный массив.  return sorted_arr
Сложность: O(n)
Объяснение сложности: время выполнения алгоритма пропорционально размеру входных данных.

Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
Работа алгоритма:
1. Объявляем функцию pancake_sort, которая принимает список arr для сортировки: def pancake_sort(arr).
2. Проходим по массиву с помощью цикла i от 0 до n-1. На каждом проходе мы будем «загонять» максимальный элемент в нужное место (в конец текущей части массива).
3. Находим индекс максимального элемента в текущем диапазоне: от 0 до n - i - 1. Изначально предполагаем, что максимальный элемент находится в начале (max_idx = 0).
Проходим по всему диапазону, сравниваем текущий элемент arr[j] с текущим максимумом arr[max_idx]. Если находим элемент большего размера, заменяем max_idx на j.
4. Если максимум уже находится на правильном месте - в конце текущей части массива - ничего не делаем.
В противном случае его нужно подвинуть туда. Переворачиваем (инвертируем) часть массива от начала до max_idx включительно: arr[:max_idx + 1] = arr[:max_idx + 1][::-1] .
5. Теперь переворачиваем весь текущий диапазон (от начала до n - i - 1):  arr[:n - i] = arr[:n - i][::-1]
При этом максимальный элемент перемещается из начала в конец текущей части массива, которая считается отсортированной после каждого прохода.
6. После завершения всех проходов возвращаем отсортированный массив: return arr
Сложность: O(n^2)
Объяснение сложности: время выполнения алгоритма зависит от квадрата размера входных данных.

Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации.
Работа алгоритма: 
1. Объявляется функция bead_sort, которая принимает список arr для сортировки.
2. Вычисляем максимум в массиве, чтобы определить высоту «столбца бусин» — количество уровней.  max_val = max(arr)
3. Создаём матрицу beads размером max_val строк и len(arr) столбцов.
4. Проходим по всему массиву. Для каждого элемента arr[i], равного числу, ставим 1 на соответствующих уровнях (от 0 до arr[i]-1), что моделирует размещение бусин на уровнях.
5. Сортируем каждую строку beads: бусины «скатываются» вниз, при этом их расположение обеспечивает естественный эффект сортировки. for row in beads: row.sort()
6. Для каждого столбца i подсчитываем количество бусин (1) в столбце. Это количество бусин и есть отсортированное значение элемента после «притягивания» бусин вниз. Присваиваем это значение элементу arr[i].
7. Возвращаем отсортированный массив. return arr
Сложность: O(n)
Объяснение сложности: время выполнения алгоритма пропорционально размеру входных данных.

Поиск скачками (Jump Search)
Определение: Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск 
внутри найденного диапазона.
Работа алгоритма:
1. Объявляем функцию jump_search, которая принимает отсортированный список arr и элемент x, который нужно найти.
2. Назначаем размер шага для прыжков - примерно равный корню из n, что является оптимальным балансом между прыжками и линейным поиском.
3. Инициализируем переменную prev, которая будет указывать на начало текущего блока (откуда начнётся линейный поиск). prev = 0
4. Пока текущий блок не достиг конца массива и последний элемент текущего блока меньше искомого x, переходим к следующему блоку: while prev < n and arr[min(prev + step, n) - 1] < x: prev += step
5. Перебираем индексы от prev до min(prev + step, n) (чтобы не выйти за границы массива). for i in range(prev, min(prev + step, n)): . Если элемент совпадает с x, возвращаем его индекс i.  if arr[i] == x: return i
6. Если элемент не найден в указанном диапазоне, возвращается -1, что означает отсутствие элемента: return -1
Сложность: O(n)
Объяснение сложности: время выполнения алгоритма пропорционально размеру входных данных.

Экспоненциальный поиск (Exponential Search)
Определение: Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.
Работа алгоритма: 
1. Объявляется функция def binary_search(arr, low, high, x), которая принимает отсортированный массив arr, элемент x, который нужно найти и диапазон low..hight.
2. Пока существует диапазон (low <= high):
Находим середину mid.
Если элемент arr[mid] равен искомому x, возвращаем индекс mid.
Если arr[mid] меньше x, ищем дальше справа — low = mid + 1.
Иначе ищем левее — high = mid - 1.
Если не нашли — возвращаем -1.
3. Объявляется функция def exponential_search(arr, x), которая принимает отсортированный массив arr и элемент x, который нужно найти.
4. Получаем длину массива n. n = len(arr). Если массив пуст, сразу возвращаем -1 - элемент не найден.
5. Проверка: если первый элемент равен искомому, можно сразу вернуть позицию 0. if arr[0] == x: return 0
6. Пока индекс внутри массива и элемент по этому индексу arr[index] меньше или равны x, делаем «экспоненциальный» скачок — умножаем index на 2. Таким образом, мы быстро находим диапазон, в котором может находиться искомое число, экспоненциально увеличивая индекс.
7. После цикла мы знаем, что искомое число, скорее всего, находится в диапазоне от index//2 до min(index, n-1)
8. Выполняем бинарный поиск в обнаруженном диапазоне, чтобы точно найти позицию x.  return binary_search(arr, low, high, x)
Сложность: O(log n)
Объяснение сложности: время выполнения алгоритма растёт медленно с увеличением размера входных данных.
